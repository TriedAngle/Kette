@syntax: \\ @parse-next ;

@syntax: \ @parse-next @namestack-lookup >box ;

@syntax: !/ \\ /! @read-until drop f ; 

@syntax: s" \\ " @read-until ; 

@syntax: const: 
    @parse-next @parse-next @parse-fixnum dup [ 
        @namestack-push
    ] [
        @parse-float dup [ @namestack-push ] [ drop @namestack-push ] if
    ] if f ;

@syntax: { \\ } @parse-until ;
@syntax: $[ \\ ] @parse-until 0 get-slot (call) ;


const: TAG_NORMAL 0
const: TAG_ARRAY 1
const: TAG_BYTEARRAY 2
const: TAG_FLOAT 3
const: TAG_BIGNUM 4
const: TAG_ALIEN 5
const: TAG_BOX 6
const: TAG_QUOTATION 7
const: TAG_WORD 8

@syntax: : 
    @parse-next dup \\ ) @read-until drop  
    \\ ; @parse-until f f quotation @create-new-instance
    TAG_QUOTATION swap @set-special-tag 
    f f word @create-new-instance
    TAG_WORD swap @set-special-tag @namestack-push f ;


: dip ( x p -- x ) swap @>r (call) @r> ;
: keep ( x [ x -- ..a ] -- ..a x ) over [ (call) ] dip ;
: bi ( x p q -- ) [ keep ] dip (call) ;
: bi* ( x y p q -- ) [ dip ] dip (call) ;
: bi@ ( x y p -- ) dup bi* ;


: is-bytearray? ( obj -- ? ) @get-special-tag TAG_BYTEARRAY fixnum= ;

: . ( obj -- )
    dup is-fixnum? [ fixnum>bytes-utf8 ] [ ] if
    println-bytes-utf8 ;


: + ( x y -- z ) 2dup is-fixnum2? [ fixnum+ ] [ 2drop f ] if ;

: bytearray-copy-full ( src dst dst-offset -- ) pick 0 get-slot 0 -rot bytearray-copy ;

: merge|size&offset ( src dst -- size offset ) swap [ swap [ 0 get-slot ] bi@ + ] keep 0 get-slot ;

: <|> ( s1 s2 -- s1s2 ) 
    2dup merge|size&offset [ swapd bytearray-resize ] dip
    swap [ swap bytearray-copy-full ] keep ;

s" likes to write elixir "  s" recommends to write elixir!" [ s" Stevejones " swap <|> . ] bi@


