VM _ModuleOpen: 'Core.

Object _Extend: Object With: { 
    extend: target With: source = {
        self _Extend: target With: source
    }
}.

Clonable = {
    parent* = Object.
    clone = {
        self _Clone: self
    }.
    copy = { self clone }.
}.

Oddball = {
    parent* = Object.
    copy = { self }.
}.

Boolean = { 
    parent* = Oddball.
}.

Object extend: Object With: { 
    truthyness* = Boolean.
}.

Object extend: Object With: {
    reflect: target = { self _Reflect: target }.
    == rhs = { self _ObjectEq: rhs }.
    != rhs = { self _ObjectNe: rhs }.
    ~= rhs = { self == rhs }.
    eqSymbol: lhs = { ^ False }.
    neSymbol: lhs = { ^ True }.
}.

Module = {
    parent* = Object.
    open: path = { VM _ModuleOpen: path }.
    use: path = {
        path asArray each: [ | importPath |
            VM _ModuleUse: importPath
        ].
        self
    }.
    use: path As: aliases = { VM _ModuleUse: path As: aliases }.
    use: path Only: names = { VM _ModuleUseOnly: path Names: (names asArray) }.
    export: names = {
        names asArray each: [ | name |
            VM _ModuleExport: name
        ].
        self
    }.
    at: path = { VM _ModuleAt: path }.
    current = { VM _CurrentModule }.
}.

VM _ModuleExport: 'Module.

Object extend: None With: {
    parent* = Oddball.
}.

Object extend: Mirror With: {
    parent* = Clonable.

    slotCount = { self _MirrorSlotCount }.
    slotNameAt: i = { self _MirrorSlotNameAt: i }.
    at: name = { self _MirrorAt: name }.
    at: name Put: value = { self _MirrorAt: name Put: value }.
    isParentAt: name = { self _MirrorIsParentAt: name }.
    isAssignableAt: name = { self _MirrorIsAssignableAt: name }.
    addSlot: name Value: value = { self _MirrorAddSlot: name Value: value }.
    removeSlot: name = { self _MirrorRemoveSlot: name }.

    eachSlot: body = {
        i := 0.
        [ i < self slotCount ] whileTrue: [
            body call: (self slotNameAt: i).
            i := i + 1
        ].
        self
    }.
}.

Object extend: False With: {
    parent* = Boolean.
    ifTrue: t ifFalse: f = { f call }.
    ifTrue: t = { None }.
    ifFalse: f = { f call }.
    ifTrue: t IfFalse: f = { f call }.
    toString = "False".
    not = { True }.
    xor: rhs = { rhs }.
    !& rhs = { True }.
    && rhs = { self }.
    || rhs = { rhs }.
}.

Object extend: Boolean With: {
    ifTrue: t ifFalse: f = { t call }.
    ifTrue: t = { t call }.
    ifFalse: f = { ^ None }.
    ifTrue: t IfFalse: f = { t call }.
    && rhs = { ^ rhs }.
    || rhs = { self }.
}.

Object extend: True With: {
    parent* = Boolean.
    ifTrue: t ifFalse: f = { t call }.
    ifTrue: t = { t call }.
    ifFalse: f = { None }.
    ifTrue: t IfFalse: f = { t call }.
    toString = "True" .
    not = { False }.
    xor: rhs = { rhs not }.
    eitherOr: rhs = { self xor: rhs }.
    !& rhs = { rhs rhs not }.
    && rhs = { rhs }.
    || rhs = { self }.
}.


Object extend: Object With: {
    cArgValue = { self }.
    asArray = {
        out := Array cloneWithSize: 1.
        out at: 0 Put: self.
        out
    }.
    pin: value = { self _Pin: value }.
    unpin: value = { self _Unpin: value }.
    isPinned: value = { self _IsPinned: value }.
    signal = { VM _Signal: self }.
}.

Object extend: VM With: {
    eval: source = { self _Eval: source }.
    withHandler: handler Do: body = { self _WithHandler: handler Do: body }.
    signal: condition = { self _Signal: condition }.
    unwind: value = { self _Unwind: value }.
    then: body Do: cleanup = { self _Then: body Do: cleanup }.
    platformOS = { self _PlatformOS }.
    platformArch = { self _PlatformArch }.
    platform = { self platformOS + "-" + self platformArch }.
}.

Object extend: Block With: {
    parent* = Clonable.
    tryCatch: catcher = {
        VM withHandler: [ | condition |
            VM unwind: (catcher call: condition)
        ] Do: self
    }.
    catch: catcher = { self tryCatch: catcher }.
    then: cleanup = { VM then: self Do: cleanup }.
    whileTrue: body = {
        self call ifTrue: [ 
            body call.
            self whileTrue: body
        ] IfFalse: [
            None 
        ]
    }.
}.

Object extend: String With: {
    parent* = Clonable.
    + rhs = {
        rhsStr := rhs toString.
        lhsBytes := self toByteArray.
        rhsBytes := rhsStr toByteArray.
        lhsLen := self length.
        rhsLen := rhsStr length.
        total := lhsLen + rhsLen.
        dst := lhsBytes cloneWithSize: total + 1.
        dst memCopy: lhsBytes From: 0 To: 0 Length: lhsLen.
        dst memCopy: rhsBytes From: 0 To: lhsLen Length: rhsLen.
        dst toString
    }.
    print = { self _Print }.
    println = { self _PrintLn }.
    length = { self _StringLength }.
    toByteArray = { self _StringToByteArray }.
    toSymbol = { self _StringToSymbol }.
    toString = { self }.
}.

Object extend: Symbol With: {
    parent* = Clonable.
    == rhs = { rhs eqSymbol: self }.
    != rhs = { rhs neSymbol: self }.
    ~= rhs = { self == rhs }.
    eqSymbol: lhs = { lhs _SymbolEq: self }.
    neSymbol: lhs = { lhs _SymbolNe: self }.
    length = { self _SymbolLength }.
    toString = { self _SymbolToString }.
    print = { self toString print }.
    println = { self toString println }.
}.

Object extend: ByteArray With: {
    parent* = Clonable.
    size = { self _ByteArraySize }.
    cloneWithSize: s = { self _CloneWithSize: s }.
    memCopy: src From: srcOffset To: dstOffset Length: len = {
        self _MemCopy: src From: srcOffset To: dstOffset Length: len
    }.
    memCopyOverlapping: src From: srcOffset To: dstOffset Length: len = {
        self _MemCopyOverlapping: src From: srcOffset To: dstOffset Length: len
    }.
    copyTo: dst From: srcOffset Length: len = {
        dst memCopy: self From: srcOffset To: 0 Length: len
    }.
    copyFrom: src Offset: srcOffset Length: len = {
        self memCopy: src From: srcOffset To: 0 Length: len
    }.
    address = { 0 }.
    isNull = { ^ False }.
    free = { ^ self }.
    toString = { self _ByteArrayToString }.
    u8At: i = { self _ByteArrayU8At: i }.
    i8At: i = { self _ByteArrayI8At: i }.
    u16At: i = { self _ByteArrayU16At: i }.
    i16At: i = { self _ByteArrayI16At: i }.
    u32At: i = { self _ByteArrayU32At: i }.
    i32At: i = { self _ByteArrayI32At: i }.
    u64At: i = { self _ByteArrayU64At: i }.
    i64At: i = { self _ByteArrayI64At: i }.
    f32At: i = { self _ByteArrayF32At: i }.
    f64At: i = { self _ByteArrayF64At: i }.
    pointerAt: i = { self _ByteArrayPointerAt: i }.
    u8At: i Put: v = { self _ByteArrayU8At: i Put: v }.
    i8At: i Put: v = { self _ByteArrayI8At: i Put: v }.
    u16At: i Put: v = { self _ByteArrayU16At: i Put: v }.
    i16At: i Put: v = { self _ByteArrayI16At: i Put: v }.
    u32At: i Put: v = { self _ByteArrayU32At: i Put: v }.
    i32At: i Put: v = { self _ByteArrayI32At: i Put: v }.
    u64At: i Put: v = { self _ByteArrayU64At: i Put: v }.
    i64At: i Put: v = { self _ByteArrayI64At: i Put: v }.
    f32At: i Put: v = { self _ByteArrayF32At: i Put: v }.
    f64At: i Put: v = { self _ByteArrayF64At: i Put: v }.
    pointerAt: i Put: v = { self _ByteArrayPointerAt: i Put: v }.
}.

VM _ModuleExport: 'Clonable.
VM _ModuleExport: 'Oddball.
VM _ModuleExport: 'Boolean.
