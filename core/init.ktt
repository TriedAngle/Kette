Object _Extend: Object With: { 
    extend: target With: source = {
        self _Extend: target With: source
    }
}.

Clonable = {
    parent* = Object.
    clone = {
        self _Clone: self
    }.
    copy = { self clone }.
}.

Oddball = {
    parent* = Object.
    copy = { self }.
}.

Boolean = { 
    parent* = Oddball.
}.

Object extend: Object With: { 
    truthyness* = Boolean.
}.

Object extend: Object With: {
    reflect: target = { self _Reflect: target }.
}.

Object extend: None With: {
    parent* = Oddball.
}.

Object extend: Mirror With: {
    parent* = Clonable.

    slotCount = { self _MirrorSlotCount }.
    slotNameAt: i = { self _MirrorSlotNameAt: i }.
    at: name = { self _MirrorAt: name }.
    at: name Put: value = { self _MirrorAt: name Put: value }.
    isParentAt: name = { self _MirrorIsParentAt: name }.
    isAssignableAt: name = { self _MirrorIsAssignableAt: name }.
    addSlot: name Value: value = { self _MirrorAddSlot: name Value: value }.
    removeSlot: name = { self _MirrorRemoveSlot: name }.

    eachSlot: body = {
        i := 0.
        [ i < self slotCount ] whileTrue: [
            body call: (self slotNameAt: i).
            i := i + 1
        ].
        self
    }.
}.

Object extend: False With: {
    parent* = Boolean.
    ifTrue: t ifFalse: f = { f call }.
    ifTrue: t = { None }.
    ifFalse: f = { f call }.
    ifTrue: t IfFalse: f = { f call }.
    toString = "False".
    not = { True }.
    xor: rhs = { rhs }.
    !& rhs = { True }.
    && rhs = { self }.
    || rhs = { rhs }.
}.

Object extend: True With: {
    parent* = Boolean.
    ifTrue: t ifFalse: f = { t call }.
    ifTrue: t = { t call }.
    ifFalse: f = { None }.
    ifTrue: t IfFalse: f = { t call }.
    toString = "True" .
    not = { False }.
    xor: rhs = { rhs not }.
    eitherOr: rhs = { self xor: rhs }.
    !& rhs = { rhs rhs not }.
    && rhs = { rhs }.
    || rhs = { self }.
}.


Object extend: Fixnum With: {
    parent* = Clonable.
    + rhs = { rhs addFixnum: self }.
    - rhs = { rhs subFixnum: self }.
    * rhs = { rhs mulFixnum: self }.
    / rhs = { rhs divFixnum: self }.
    % rhs = { rhs modFixnum: self }.

    == rhs = { rhs eqFixnum: self }.
    != rhs = { rhs neFixnum: self }.
    < rhs = { rhs ltFixnum: self }.
    <= rhs = { rhs leFixnum: self }.
    > rhs = { rhs gtFixnum: self }.
    >= rhs = { rhs geFixnum: self }.
    ~= rhs = { self == rhs }.

    addFixnum: lhs = { lhs _FixnumAdd: self }.
    subFixnum: lhs = { lhs _FixnumSub: self }.
    mulFixnum: lhs = { lhs _FixnumMul: self }.
    divFixnum: lhs = { lhs _FixnumDiv: self }.
    modFixnum: lhs = { lhs _FixnumMod: self }.

    addBignum: lhs = { lhs _BignumAdd: (self _FixnumToBignum) }.
    subBignum: lhs = { lhs _BignumSub: (self _FixnumToBignum) }.
    mulBignum: lhs = { lhs _BignumMul: (self _FixnumToBignum) }.
    divBignum: lhs = { lhs _BignumDiv: (self _FixnumToBignum) }.
    modBignum: lhs = { lhs _BignumMod: (self _FixnumToBignum) }.

    addRatio: lhs = { lhs _RatioAdd: (self _FixnumToRatio) }.
    subRatio: lhs = { lhs _RatioSub: (self _FixnumToRatio) }.
    mulRatio: lhs = { lhs _RatioMul: (self _FixnumToRatio) }.
    divRatio: lhs = { lhs _RatioDiv: (self _FixnumToRatio) }.

    addFloat: lhs = { lhs _FloatAdd: (self _FixnumToFloat) }.
    subFloat: lhs = { lhs _FloatSub: (self _FixnumToFloat) }.
    mulFloat: lhs = { lhs _FloatMul: (self _FixnumToFloat) }.
    divFloat: lhs = { lhs _FloatDiv: (self _FixnumToFloat) }.
    modFloat: lhs = { lhs _FloatMod: (self _FixnumToFloat) }.

    neg = { self _FixnumNeg }.
    sqrt = { (self _FixnumToFloat) sqrt }.

    toString = { self _FixnumToString }.
    toStringRadix: r = { self _FixnumToStringRadix: r }.

    eqFixnum: lhs = { lhs _FixnumEq: self }.
    neFixnum: lhs = { lhs _FixnumNe: self }.
    ltFixnum: lhs = { lhs _FixnumLt: self }.
    leFixnum: lhs = { lhs _FixnumLe: self }.
    gtFixnum: lhs = { lhs _FixnumGt: self }.
    geFixnum: lhs = { lhs _FixnumGe: self }.
    equals: rhs WithEpsilon: e = { self == rhs }.

    eqBignum: lhs = { lhs _BignumEq: (self _FixnumToBignum) }.
    neBignum: lhs = { lhs _BignumNe: (self _FixnumToBignum) }.
    ltBignum: lhs = { lhs _BignumLt: (self _FixnumToBignum) }.
    leBignum: lhs = { lhs _BignumLe: (self _FixnumToBignum) }.
    gtBignum: lhs = { lhs _BignumGt: (self _FixnumToBignum) }.
    geBignum: lhs = { lhs _BignumGe: (self _FixnumToBignum) }.

    eqRatio: lhs = { lhs _RatioEq: (self _FixnumToRatio) }.
    neRatio: lhs = { lhs _RatioNe: (self _FixnumToRatio) }.
    ltRatio: lhs = { lhs _RatioLt: (self _FixnumToRatio) }.
    leRatio: lhs = { lhs _RatioLe: (self _FixnumToRatio) }.
    gtRatio: lhs = { lhs _RatioGt: (self _FixnumToRatio) }.
    geRatio: lhs = { lhs _RatioGe: (self _FixnumToRatio) }.

    eqFloat: lhs = { lhs _FloatEq: (self _FixnumToFloat) }.
    neFloat: lhs = { lhs _FloatNe: (self _FixnumToFloat) }.
    ltFloat: lhs = { lhs _FloatLt: (self _FixnumToFloat) }.
    leFloat: lhs = { lhs _FloatLe: (self _FixnumToFloat) }.
    gtFloat: lhs = { lhs _FloatGt: (self _FixnumToFloat) }.
    geFloat: lhs = { lhs _FloatGe: (self _FixnumToFloat) }.
}.

Object extend: Bignum With: {
    parent* = Clonable.
    + rhs = { rhs addBignum: self }.
    - rhs = { rhs subBignum: self }.
    * rhs = { rhs mulBignum: self }.
    / rhs = { rhs divBignum: self }.
    % rhs = { rhs modBignum: self }.

    == rhs = { rhs eqBignum: self }.
    != rhs = { rhs neBignum: self }.
    < rhs = { rhs ltBignum: self }.
    <= rhs = { rhs leBignum: self }.
    > rhs = { rhs gtBignum: self }.
    >= rhs = { rhs geBignum: self }.
    ~= rhs = { self == rhs }.

    addFixnum: lhs = { (lhs _FixnumToBignum) _BignumAdd: self }.
    subFixnum: lhs = { (lhs _FixnumToBignum) _BignumSub: self }.
    mulFixnum: lhs = { (lhs _FixnumToBignum) _BignumMul: self }.
    divFixnum: lhs = { (lhs _FixnumToBignum) _BignumDiv: self }.
    modFixnum: lhs = { (lhs _FixnumToBignum) _BignumMod: self }.

    addBignum: lhs = { lhs _BignumAdd: self }.
    subBignum: lhs = { lhs _BignumSub: self }.
    mulBignum: lhs = { lhs _BignumMul: self }.
    divBignum: lhs = { lhs _BignumDiv: self }.
    modBignum: lhs = { lhs _BignumMod: self }.

    addRatio: lhs = { lhs _RatioAdd: (self _BignumToRatio) }.
    subRatio: lhs = { lhs _RatioSub: (self _BignumToRatio) }.
    mulRatio: lhs = { lhs _RatioMul: (self _BignumToRatio) }.
    divRatio: lhs = { lhs _RatioDiv: (self _BignumToRatio) }.

    addFloat: lhs = { lhs _FloatAdd: (self _BignumToFloat) }.
    subFloat: lhs = { lhs _FloatSub: (self _BignumToFloat) }.
    mulFloat: lhs = { lhs _FloatMul: (self _BignumToFloat) }.
    divFloat: lhs = { lhs _FloatDiv: (self _BignumToFloat) }.
    modFloat: lhs = { lhs _FloatMod: (self _BignumToFloat) }.

    neg = { self _BignumNeg }.
    sqrt = { (self _BignumToFloat) sqrt }.

    eqFixnum: lhs = { (lhs _FixnumToBignum) _BignumEq: self }.
    neFixnum: lhs = { (lhs _FixnumToBignum) _BignumNe: self }.
    ltFixnum: lhs = { (lhs _FixnumToBignum) _BignumLt: self }.
    leFixnum: lhs = { (lhs _FixnumToBignum) _BignumLe: self }.
    gtFixnum: lhs = { (lhs _FixnumToBignum) _BignumGt: self }.
    geFixnum: lhs = { (lhs _FixnumToBignum) _BignumGe: self }.
    equals: rhs WithEpsilon: e = { self == rhs }.

    eqBignum: lhs = { lhs _BignumEq: self }.
    neBignum: lhs = { lhs _BignumNe: self }.
    ltBignum: lhs = { lhs _BignumLt: self }.
    leBignum: lhs = { lhs _BignumLe: self }.
    gtBignum: lhs = { lhs _BignumGt: self }.
    geBignum: lhs = { lhs _BignumGe: self }.

    eqRatio: lhs = { lhs _RatioEq: (self _BignumToRatio) }.
    neRatio: lhs = { lhs _RatioNe: (self _BignumToRatio) }.
    ltRatio: lhs = { lhs _RatioLt: (self _BignumToRatio) }.
    leRatio: lhs = { lhs _RatioLe: (self _BignumToRatio) }.
    gtRatio: lhs = { lhs _RatioGt: (self _BignumToRatio) }.
    geRatio: lhs = { lhs _RatioGe: (self _BignumToRatio) }.

    eqFloat: lhs = { lhs _FloatEq: (self _BignumToFloat) }.
    neFloat: lhs = { lhs _FloatNe: (self _BignumToFloat) }.
    ltFloat: lhs = { lhs _FloatLt: (self _BignumToFloat) }.
    leFloat: lhs = { lhs _FloatLe: (self _BignumToFloat) }.
    gtFloat: lhs = { lhs _FloatGt: (self _BignumToFloat) }.
    geFloat: lhs = { lhs _FloatGe: (self _BignumToFloat) }.

    toString = { self _BignumToString }.
}.

Object extend: Ratio With: {
    parent* = Clonable.
    + rhs = { rhs addRatio: self }.
    - rhs = { rhs subRatio: self }.
    * rhs = { rhs mulRatio: self }.
    / rhs = { rhs divRatio: self }.

    == rhs = { rhs eqRatio: self }.
    != rhs = { rhs neRatio: self }.
    < rhs = { rhs ltRatio: self }.
    <= rhs = { rhs leRatio: self }.
    > rhs = { rhs gtRatio: self }.
    >= rhs = { rhs geRatio: self }.
    ~= rhs = { self == rhs }.

    addFixnum: lhs = { (lhs _FixnumToRatio) _RatioAdd: self }.
    subFixnum: lhs = { (lhs _FixnumToRatio) _RatioSub: self }.
    mulFixnum: lhs = { (lhs _FixnumToRatio) _RatioMul: self }.
    divFixnum: lhs = { (lhs _FixnumToRatio) _RatioDiv: self }.

    addBignum: lhs = { (lhs _BignumToRatio) _RatioAdd: self }.
    subBignum: lhs = { (lhs _BignumToRatio) _RatioSub: self }.
    mulBignum: lhs = { (lhs _BignumToRatio) _RatioMul: self }.
    divBignum: lhs = { (lhs _BignumToRatio) _RatioDiv: self }.

    addRatio: lhs = { lhs _RatioAdd: self }.
    subRatio: lhs = { lhs _RatioSub: self }.
    mulRatio: lhs = { lhs _RatioMul: self }.
    divRatio: lhs = { lhs _RatioDiv: self }.

    addFloat: lhs = { lhs _FloatAdd: (self _RatioToFloat) }.
    subFloat: lhs = { lhs _FloatSub: (self _RatioToFloat) }.
    mulFloat: lhs = { lhs _FloatMul: (self _RatioToFloat) }.
    divFloat: lhs = { lhs _FloatDiv: (self _RatioToFloat) }.

    neg = { self _RatioNeg }.
    sqrt = { (self _RatioToFloat) sqrt }.

    eqFixnum: lhs = { (lhs _FixnumToRatio) _RatioEq: self }.
    neFixnum: lhs = { (lhs _FixnumToRatio) _RatioNe: self }.
    ltFixnum: lhs = { (lhs _FixnumToRatio) _RatioLt: self }.
    leFixnum: lhs = { (lhs _FixnumToRatio) _RatioLe: self }.
    gtFixnum: lhs = { (lhs _FixnumToRatio) _RatioGt: self }.
    geFixnum: lhs = { (lhs _FixnumToRatio) _RatioGe: self }.
    equals: rhs WithEpsilon: e = { self == rhs }.

    eqBignum: lhs = { (lhs _BignumToRatio) _RatioEq: self }.
    neBignum: lhs = { (lhs _BignumToRatio) _RatioNe: self }.
    ltBignum: lhs = { (lhs _BignumToRatio) _RatioLt: self }.
    leBignum: lhs = { (lhs _BignumToRatio) _RatioLe: self }.
    gtBignum: lhs = { (lhs _BignumToRatio) _RatioGt: self }.
    geBignum: lhs = { (lhs _BignumToRatio) _RatioGe: self }.

    eqRatio: lhs = { lhs _RatioEq: self }.
    neRatio: lhs = { lhs _RatioNe: self }.
    ltRatio: lhs = { lhs _RatioLt: self }.
    leRatio: lhs = { lhs _RatioLe: self }.
    gtRatio: lhs = { lhs _RatioGt: self }.
    geRatio: lhs = { lhs _RatioGe: self }.

    eqFloat: lhs = { lhs _FloatEq: (self _RatioToFloat) }.
    neFloat: lhs = { lhs _FloatNe: (self _RatioToFloat) }.
    ltFloat: lhs = { lhs _FloatLt: (self _RatioToFloat) }.
    leFloat: lhs = { lhs _FloatLe: (self _RatioToFloat) }.
    gtFloat: lhs = { lhs _FloatGt: (self _RatioToFloat) }.
    geFloat: lhs = { lhs _FloatGe: (self _RatioToFloat) }.

    numerator = { self _RatioNumerator }.
    denominator = { self _RatioDenominator }.
    toString = { self _RatioToString }.
}.

Object extend: Float With: {
    parent* = Clonable.
    epsilon = 1e-9.
    + rhs = { rhs addFloat: self }.
    - rhs = { rhs subFloat: self }.
    * rhs = { rhs mulFloat: self }.
    / rhs = { rhs divFloat: self }.
    % rhs = { rhs modFloat: self }.
    == rhs = { rhs eqFloat: self }.
    != rhs = { rhs neFloat: self }.
    < rhs = { rhs ltFloat: self }.
    <= rhs = { rhs leFloat: self }.
    > rhs = { rhs gtFloat: self }.
    >= rhs = { rhs geFloat: self }.
    ~= rhs = { self equals: rhs WithEpsilon: self epsilon }.

    addFixnum: lhs = { (lhs _FixnumToFloat) _FloatAdd: self }.
    subFixnum: lhs = { (lhs _FixnumToFloat) _FloatSub: self }.
    mulFixnum: lhs = { (lhs _FixnumToFloat) _FloatMul: self }.
    divFixnum: lhs = { (lhs _FixnumToFloat) _FloatDiv: self }.
    modFixnum: lhs = { (lhs _FixnumToFloat) _FloatMod: self }.

    addBignum: lhs = { (lhs _BignumToFloat) _FloatAdd: self }.
    subBignum: lhs = { (lhs _BignumToFloat) _FloatSub: self }.
    mulBignum: lhs = { (lhs _BignumToFloat) _FloatMul: self }.
    divBignum: lhs = { (lhs _BignumToFloat) _FloatDiv: self }.
    modBignum: lhs = { (lhs _BignumToFloat) _FloatMod: self }.

    addRatio: lhs = { (lhs _RatioToFloat) _FloatAdd: self }.
    subRatio: lhs = { (lhs _RatioToFloat) _FloatSub: self }.
    mulRatio: lhs = { (lhs _RatioToFloat) _FloatMul: self }.
    divRatio: lhs = { (lhs _RatioToFloat) _FloatDiv: self }.

    addFloat: lhs = { lhs _FloatAdd: self }.
    subFloat: lhs = { lhs _FloatSub: self }.
    mulFloat: lhs = { lhs _FloatMul: self }.
    divFloat: lhs = { lhs _FloatDiv: self }.
    modFloat: lhs = { lhs _FloatMod: self }.

    equals: rhs WithEpsilon: e = { self _FloatApproxEq: rhs WithEpsilon: e }.

    eqFixnum: lhs = { (lhs _FixnumToFloat) _FloatEq: self }.
    neFixnum: lhs = { (lhs _FixnumToFloat) _FloatNe: self }.
    ltFixnum: lhs = { (lhs _FixnumToFloat) _FloatLt: self }.
    leFixnum: lhs = { (lhs _FixnumToFloat) _FloatLe: self }.
    gtFixnum: lhs = { (lhs _FixnumToFloat) _FloatGt: self }.
    geFixnum: lhs = { (lhs _FixnumToFloat) _FloatGe: self }.

    eqBignum: lhs = { (lhs _BignumToFloat) _FloatEq: self }.
    neBignum: lhs = { (lhs _BignumToFloat) _FloatNe: self }.
    ltBignum: lhs = { (lhs _BignumToFloat) _FloatLt: self }.
    leBignum: lhs = { (lhs _BignumToFloat) _FloatLe: self }.
    gtBignum: lhs = { (lhs _BignumToFloat) _FloatGt: self }.
    geBignum: lhs = { (lhs _BignumToFloat) _FloatGe: self }.

    eqRatio: lhs = { (lhs _RatioToFloat) _FloatEq: self }.
    neRatio: lhs = { (lhs _RatioToFloat) _FloatNe: self }.
    ltRatio: lhs = { (lhs _RatioToFloat) _FloatLt: self }.
    leRatio: lhs = { (lhs _RatioToFloat) _FloatLe: self }.
    gtRatio: lhs = { (lhs _RatioToFloat) _FloatGt: self }.
    geRatio: lhs = { (lhs _RatioToFloat) _FloatGe: self }.

    eqFloat: lhs = { lhs _FloatEq: self }.
    neFloat: lhs = { lhs _FloatNe: self }.
    ltFloat: lhs = { lhs _FloatLt: self }.
    leFloat: lhs = { lhs _FloatLe: self }.
    gtFloat: lhs = { lhs _FloatGt: self }.
    geFloat: lhs = { lhs _FloatGe: self }.

    neg = { self _FloatNeg }.
    toString = { self _FloatToString }.
    toStringDigits: d = { self _FloatToStringDigits: d }.
}.

Complex = {
    re := 0.
    im := 0.
    parent* = Clonable.

    asComplex = { self }.
    setRe: r Im: i = { self re: r. self im: i. self }.

    + rhs = {
        o = rhs asComplex.
        Complex clone setRe: self re + o re Im: self im + o im
    }.

    - rhs = {
        o = rhs asComplex.
        Complex clone setRe: self re - o re Im: self im - o im
    }.

    * rhs = {
        o = rhs asComplex.
        Complex clone setRe: ((self re * o re) - (self im * o im)) Im: ((self re * o im) + (self im * o re))
    }.

    / rhs = {
        o = rhs asComplex.
        denom := (o re * o re) + (o im * o im).
        denom == 0 ifTrue: [ 1 / 0 ] IfFalse: [
            Complex clone setRe: ((self re * o re + self im * o im) / denom) Im: ((self im * o re - self re * o im) / denom)
        ]
    }.

    == rhs = {
        o = rhs asComplex.
        self re == o re && self im == o im
    }.

    != rhs = { self == rhs ifTrue: [ False ] IfFalse: [ True ] }.
    ~= rhs = { self == rhs }.


    addFixnum: lhs = { lhs asComplex + self }.
    subFixnum: lhs = { lhs asComplex - self }.
    mulFixnum: lhs = { lhs asComplex * self }.
    divFixnum: lhs = { lhs asComplex / self }.

    addBignum: lhs = { lhs asComplex + self }.
    subBignum: lhs = { lhs asComplex - self }.
    mulBignum: lhs = { lhs asComplex * self }.
    divBignum: lhs = { lhs asComplex / self }.

    addRatio: lhs = { lhs asComplex + self }.
    subRatio: lhs = { lhs asComplex - self }.
    mulRatio: lhs = { lhs asComplex * self }.
    divRatio: lhs = { lhs asComplex / self }.

    addFloat: lhs = { lhs asComplex + self }.
    subFloat: lhs = { lhs asComplex - self }.
    mulFloat: lhs = { lhs asComplex * self }.
    divFloat: lhs = { lhs asComplex / self }.

    conjugate = { Complex clone setRe: self re Im: 0 - self im }.
    magnitudeSquared = { self re * self re + self im * self im }.
    abs = { self magnitudeSquared sqrt }.
    isReal = { self im == 0 }.
    equals: rhs WithEpsilon: e = {
        o = rhs asComplex.
        (self re equals: o re WithEpsilon: e) && (self im equals: o im WithEpsilon: e)
    }.

    toString = {
        self im < 0 ifTrue: [
            self re toString + " - " + (0 - self im) toString + "i"
        ] IfFalse: [
            self re toString + " + " + self im toString + "i"
        ]
    }.
}.

Object extend: Float With: {
    sqrt = {
        self < 0 ifTrue: [
            ^ (Complex clone setRe: 0 Im: ((0 - self) _FloatSqrt))
        ] IfFalse: [
            ^ (self _FloatSqrt)
        ]
    }.
}.

Object extend: Object With: {
    asComplex = { Complex clone setRe: self Im: 0 }.
    cArgValue = { self }.
    asArray = {
        out := Array cloneWithSize: 1.
        out at: 0 Put: self.
        out
    }.
    & rhs = { Collector with: self With: rhs }.
    pin: value = { self _Pin: value }.
    unpin: value = { self _Unpin: value }.
    isPinned: value = { self _IsPinned: value }.
}.

Object extend: VM With: {
    eval: source = { self _Eval: source }.
}.

Object extend: Block With: {
    parent* = Clonable.
    whileTrue: body = {
        self call ifTrue: [ 
            body call.
            self whileTrue: body
        ] IfFalse: [
            None 
        ]
    }.
}.

Object extend: String With: {
    parent* = Clonable.
    + rhs = {
        rhsStr := rhs toString.
        lhsBytes := self toByteArray.
        rhsBytes := rhsStr toByteArray.
        lhsLen := self length.
        rhsLen := rhsStr length.
        total := lhsLen + rhsLen.
        dst := lhsBytes cloneWithSize: total + 1.
        dst memCopy: lhsBytes From: 0 To: 0 Length: lhsLen.
        dst memCopy: rhsBytes From: 0 To: lhsLen Length: rhsLen.
        dst toString
    }.
    print = { self _Print }.
    println = { self _PrintLn }.
    length = { self _StringLength }.
    toByteArray = { self _StringToByteArray }.
    toString = { self }.
}.

Sequence = {
    parent* = Clonable.
    each: body = { self }.
}.

IndexedSequence = {
    parent* = Sequence.
    each: body = {
        i := 0.
        [ i < self size ] whileTrue: [
            body call: (self at: i).
            i := i + 1
        ].
        self
    }.
}.

Object extend: Array With: {
    parent* = IndexedSequence.
    size = { self _ArraySize }.
    cloneWithSize: s = { self _ArrayCloneWithSize: s }.
    at: index = { self _ArrayAt: index }.
    at: index Put: value = { self _ArrayAt: index Put: value }.
    asArray = { self }.
}.

CollectorChunk = {
    parent* = Clonable.
    values := None.
    next := None.

    withSize: s = {
        {
            parent* = CollectorChunk.
            values := Array cloneWithSize: s.
            next := None
        }
    }.
}.

Collector = {
    parent* = Clonable.
    firstChunk := None.
    currentChunk := None.
    currentIndex := 0.
    count := 0.
    nextChunkSize := 8.

    with: first With: second = {
        c := Collector clone init.
        c add: first.
        c add: second
    }.

    init = {
        first := CollectorChunk withSize: self nextChunkSize.
        self firstChunk: first.
        self currentChunk: first.
        self currentIndex: 0.
        self count: 0.
        self nextChunkSize: self nextChunkSize * 2.
        self
    }.

    allocateNextChunk = {
        next := CollectorChunk withSize: self nextChunkSize.
        self currentChunk next: next.
        self currentChunk: next.
        self currentIndex: 0.
        self nextChunkSize: self nextChunkSize * 2.
        self
    }.

    add: value = {
        currentSize := self currentChunk values size.
        i := self currentIndex.
        i == currentSize ifTrue: [
            self allocateNextChunk.
            i := self currentIndex
        ] IfFalse: [
            self
        ].
        self currentChunk values at: i Put: value.
        self currentIndex: i + 1.
        self count: self count + 1.
        self
    }.

    asArray = {
        out := Array cloneWithSize: self count.
        chunk := self firstChunk.
        chunkValues := chunk values.
        chunkIndex := 0.
        outIndex := 0.
        [ outIndex < self count ] whileTrue: [
            chunkSize := chunkValues size.
            chunkIndex == chunkSize ifTrue: [
                chunk := chunk next.
                chunkValues := chunk values.
                chunkIndex := 0
            ] IfFalse: [
                self
            ].
            out at: outIndex Put: (chunkValues at: chunkIndex).
            outIndex := outIndex + 1.
            chunkIndex := chunkIndex + 1
        ].
        out
    }.

    debugPrint = {
        ("Collector(count=" + self count toString + ", currentIndex=" + self currentIndex toString + ", nextChunkSize=" + self nextChunkSize toString + ")") println.
        ("Collector(firstChunkSize=" + self firstChunk values size toString + ", currentChunkSize=" + self currentChunk values size toString + ")") println.
        self
    }.
}.

Object extend: Collector With: {
    & rhs = { self add: rhs }.
}.

Object extend: ByteArray With: {
    parent* = Clonable.
    size = { self _ByteArraySize }.
    cloneWithSize: s = { self _CloneWithSize: s }.
    memCopy: src From: srcOffset To: dstOffset Length: len = {
        self _MemCopy: src From: srcOffset To: dstOffset Length: len
    }.
    memCopyOverlapping: src From: srcOffset To: dstOffset Length: len = {
        self _MemCopyOverlapping: src From: srcOffset To: dstOffset Length: len
    }.
    copyTo: dst From: srcOffset Length: len = {
        dst memCopy: self From: srcOffset To: 0 Length: len
    }.
    copyFrom: src Offset: srcOffset Length: len = {
        self memCopy: src From: srcOffset To: 0 Length: len
    }.
    address = { 0 }.
    isNull = { ^ False }.
    free = { ^ self }.
    toString = { self _ByteArrayToString }.
    u8At: i = { self _ByteArrayU8At: i }.
    i8At: i = { self _ByteArrayI8At: i }.
    u16At: i = { self _ByteArrayU16At: i }.
    i16At: i = { self _ByteArrayI16At: i }.
    u32At: i = { self _ByteArrayU32At: i }.
    i32At: i = { self _ByteArrayI32At: i }.
    u64At: i = { self _ByteArrayU64At: i }.
    i64At: i = { self _ByteArrayI64At: i }.
    f32At: i = { self _ByteArrayF32At: i }.
    f64At: i = { self _ByteArrayF64At: i }.
    pointerAt: i = { self _ByteArrayPointerAt: i }.
    u8At: i Put: v = { self _ByteArrayU8At: i Put: v }.
    i8At: i Put: v = { self _ByteArrayI8At: i Put: v }.
    u16At: i Put: v = { self _ByteArrayU16At: i Put: v }.
    i16At: i Put: v = { self _ByteArrayI16At: i Put: v }.
    u32At: i Put: v = { self _ByteArrayU32At: i Put: v }.
    i32At: i Put: v = { self _ByteArrayI32At: i Put: v }.
    u64At: i Put: v = { self _ByteArrayU64At: i Put: v }.
    i64At: i Put: v = { self _ByteArrayI64At: i Put: v }.
    f32At: i Put: v = { self _ByteArrayF32At: i Put: v }.
    f64At: i Put: v = { self _ByteArrayF64At: i Put: v }.
    pointerAt: i Put: v = { self _ByteArrayPointerAt: i Put: v }.
}.

Object extend: Alien With: {
    parent* = Clonable.
    new: s = { self _AlienNew: s }.
    fromAddress: addr Size: s = { self _AlienFromAddress: addr Size: s }.
    libraryOpen: path = { self _LibraryOpen: path }.
    free = { self _AlienFree }.
    size = { self _AlienSize }.
    address = { self _AlienAddress }.
    isNull = { self _AlienIsNull }.
    librarySym: name = { self _LibrarySym: name }.
    libraryClose = { self _LibraryClose }.
    copyTo: dst From: srcOffset Length: len = {
        self _AlienCopyTo: dst From: srcOffset Length: len
    }.
    copyFrom: src Offset: srcOffset Length: len = {
        self _AlienCopyFrom: src Offset: srcOffset Length: len
    }.
    u8At: i = { self _AlienU8At: i }.
    i8At: i = { self _AlienI8At: i }.
    u16At: i = { self _AlienU16At: i }.
    i16At: i = { self _AlienI16At: i }.
    u32At: i = { self _AlienU32At: i }.
    i32At: i = { self _AlienI32At: i }.
    u64At: i = { self _AlienU64At: i }.
    i64At: i = { self _AlienI64At: i }.
    f32At: i = { self _AlienF32At: i }.
    f64At: i = { self _AlienF64At: i }.
    pointerAt: i = { self _AlienPointerAt: i }.
    u8At: i Put: v = { self _AlienU8At: i Put: v }.
    i8At: i Put: v = { self _AlienI8At: i Put: v }.
    u16At: i Put: v = { self _AlienU16At: i Put: v }.
    i16At: i Put: v = { self _AlienI16At: i Put: v }.
    u32At: i Put: v = { self _AlienU32At: i Put: v }.
    i32At: i Put: v = { self _AlienI32At: i Put: v }.
    u64At: i Put: v = { self _AlienU64At: i Put: v }.
    i64At: i Put: v = { self _AlienI64At: i Put: v }.
    f32At: i Put: v = { self _AlienF32At: i Put: v }.
    f64At: i Put: v = { self _AlienF64At: i Put: v }.
    pointerAt: i Put: v = { self _AlienPointerAt: i Put: v }.
    callWithTypes: types Args: values ReturnType: ret = {
        typeArray := types asArray.
        valueArray := values asArray.
        lowered := Array cloneWithSize: valueArray size.
        i := 0.
        [ i < valueArray size ] whileTrue: [
            lowered at: i Put: ((valueArray at: i) cArgValue).
            i := i + 1
        ].
        self _AlienCallWithTypes: typeArray Args: lowered ReturnType: ret
    }.
}.

Proxy := {
    parent* = Clonable.
    backing := None.
    ctype := None.

    fromBacking: b = {
        p := { parent* = Proxy. backing := b. ctype = None }.
        p
    }.
    fromCType: t Backing: b = {
        p := { parent* = Proxy. backing := b. ctype = t }.
        p
    }.
    forAlienSize: s = { self fromBacking: (Alien new: s) }.
    forByteArraySize: s = { self fromBacking: (ByteArray cloneWithSize: s) }.
    forCType: t = { self fromCType: t Backing: (ByteArray cloneWithSize: t size) }.
    size = { backing size }.
    address = { backing address }.
    isNull = { backing isNull }.
    free = { backing free }.
    copyTo: dst From: srcOffset Length: len = {
        backing copyTo: dst From: srcOffset Length: len
    }.
    copyFrom: src Offset: srcOffset Length: len = {
        backing copyFrom: src Offset: srcOffset Length: len
    }.
    u8At: i = { backing u8At: i }.
    i8At: i = { backing i8At: i }.
    u16At: i = { backing u16At: i }.
    i16At: i = { backing i16At: i }.
    u32At: i = { backing u32At: i }.
    i32At: i = { backing i32At: i }.
    u64At: i = { backing u64At: i }.
    i64At: i = { backing i64At: i }.
    f32At: i = { backing f32At: i }.
    f64At: i = { backing f64At: i }.
    pointerAt: i = { backing pointerAt: i }.
    u8At: i Put: v = { backing u8At: i Put: v }.
    i8At: i Put: v = { backing i8At: i Put: v }.
    u16At: i Put: v = { backing u16At: i Put: v }.
    i16At: i Put: v = { backing i16At: i Put: v }.
    u32At: i Put: v = { backing u32At: i Put: v }.
    i32At: i Put: v = { backing i32At: i Put: v }.
    u64At: i Put: v = { backing u64At: i Put: v }.
    i64At: i Put: v = { backing i64At: i Put: v }.
    f32At: i Put: v = { backing f32At: i Put: v }.
    f64At: i Put: v = { backing f64At: i Put: v }.
    pointerAt: i Put: v = { backing pointerAt: i Put: v }.
    callWithTypes: types Args: values ReturnType: ret = {
        backing callWithTypes: types Args: values ReturnType: ret
    }.

    readCType: t At: offset = {
        t proxyReadFrom: self At: offset
    }.

    writeCType: t At: offset Value: value = {
        t proxyWriteTo: self At: offset Value: value
    }.

    atField: name = {
        info := self ctype _CTypeFieldInfoAt: name.
        self readCType: info type At: info offset
    }.

    atField: name Put: value = {
        info := self ctype _CTypeFieldInfoAt: name.
        self writeCType: info type At: info offset Value: value.
        value
    }.

    cArgValue = { backing cArgValue }.
    pin = { Object pin: backing. self }.
    unpin = { Object unpin: backing. self }.
    isPinned = { Object isPinned: backing }.
}.

Disposable := {
    parent* = Clonable.
    disposed = { False }.
    dispose = { self }.
    using: body = {
        result := body call: self.
        self dispose.
        result
    }.
}.

File := {
    parent* = Disposable.
    fd := -1.
    path = "".
    flags = 0.

    open: path Flags: flags Mode: mode = {
        fd := Posix open: path Flags: flags Mode: mode.
        {
            parent* = File.
            fd := fd.
            path = path.
            flags = flags
        }
    }.

    isOpen = { self fd >= 0 }.
    disposed = { self isOpen not }.

    close = {
        self isOpen
            ifTrue: [
                rc := Posix closeFd: self fd.
                self fd: -1.
                rc
            ]
            IfFalse: [ 0 ]
    }.

    dispose = { self close. self }.

    size = {
        self isOpen
            ifTrue: [ Posix seekFd: self fd Offset: 0 Whence: Posix SEEK_END ]
            IfFalse: [ self _FileClosed ]
    }.

    statSize = {
        self isOpen
            ifTrue: [
                statBuf := ByteArray cloneWithSize: CStatLinuxX64 size.
                rc := Posix fstatFd: self fd Into: statBuf.
                rc == 0
                    ifTrue: [
                        statInfo := CStatLinuxX64 _CTypeFieldInfoAt: "st_size".
                        statOffset := statInfo offset.
                        statBuf i64At: statOffset
                    ]
                    IfFalse: [ self _FstatFailed: rc ]
            ]
            IfFalse: [ self _FileClosed ]
    }.

    readInto: buffer Length: len = {
        self isOpen
            ifTrue: [ Posix readFd: self fd Into: buffer Length: len ]
            IfFalse: [ self _FileClosed ]
    }.

    rewind = {
        self isOpen
            ifTrue: [ Posix seekFd: self fd Offset: 0 Whence: Posix SEEK_SET ]
            IfFalse: [ self _FileClosed ]
    }.

    readFirstLines: lineCount = {
        self rewind.
        buffer := ByteArray cloneWithSize: 8192.
        bytesRead := self readInto: buffer Length: buffer size.
        bytesRead <= 0
            ifTrue: [ "" ]
            IfFalse: [
                stop := bytesRead.
                lines := 0.
                i := 0.
                [ i < bytesRead ] whileTrue: [
                    (buffer u8At: i) == 10
                        ifTrue: [
                            lines := lines + 1.
                            lines >= lineCount
                                ifTrue: [
                                    stop := i + 1.
                                    i := bytesRead
                                ]
                                IfFalse: [ None ]
                        ]
                        IfFalse: [ None ].
                    i := i + 1
                ].

                out := ByteArray cloneWithSize: stop + 1.
                out memCopy: buffer From: 0 To: 0 Length: stop.
                out toString
            ]
    }.

    eachLine: body First: lineCount = {
        content := self readFirstLines: lineCount.
        bytes := content toByteArray.
        total := content length.

        start := 0.
        i := 0.
        [ i < total ] whileTrue: [
            (bytes u8At: i) == 10
                ifTrue: [
                    lineLen := i - start.
                    lineBytes := ByteArray cloneWithSize: lineLen + 1.
                    lineBytes memCopy: bytes From: start To: 0 Length: lineLen.
                    body call: lineBytes toString.
                    start := i + 1
                ]
                IfFalse: [ None ].
            i := i + 1
        ].

        start < total
            ifTrue: [
                lineLen := total - start.
                lineBytes := ByteArray cloneWithSize: lineLen + 1.
                lineBytes memCopy: bytes From: start To: 0 Length: lineLen.
                body call: lineBytes toString
            ]
            IfFalse: [ None ].
        self
    }.

    eachLine: body = {
        self rewind.
        total := self statSize.
        bytes := ByteArray cloneWithSize: total + 1.
        total := self readInto: bytes Length: total.

        start := 0.
        i := 0.
        [ i < total ] whileTrue: [
            (bytes u8At: i) == 10
                ifTrue: [
                    lineLen := i - start.
                    lineBytes := ByteArray cloneWithSize: lineLen + 1.
                    lineBytes memCopy: bytes From: start To: 0 Length: lineLen.
                    body call: lineBytes toString.
                    start := i + 1
                ]
                IfFalse: [ None ].
            i := i + 1
        ].

        start < total
            ifTrue: [
                lineLen := total - start.
                lineBytes := ByteArray cloneWithSize: lineLen + 1.
                lineBytes memCopy: bytes From: start To: 0 Length: lineLen.
                body call: lineBytes toString
            ]
            IfFalse: [ None ].
        self
    }.

    printFirstLines: lineCount = {
        content := self readFirstLines: lineCount.
        content print.
        self
    }.
}.

CType := {
    parent* = Oddball.
    scalarTag: tag Size: s Align: a = {
        {
            parent* = self.
            impl = tag.
            size = s.
            align = a
        }
    }.

    scalarTag = { self _CTypeScalarTag }.
    struct: definition = { self _CTypeBuildStruct: definition }.
    fieldInfoAt: name = { self _CTypeFieldInfoAt: name }.
    fieldOffsetAt: name = { (self fieldInfoAt: name) offset }.
    fieldTypeAt: name = { (self fieldInfoAt: name) type }.

    proxyReadFrom: proxy At: offset = {
        proxy _ProxyUnsupportedCTypeRead: self
    }.

    proxyWriteTo: proxy At: offset Value: value = {
        proxy _ProxyUnsupportedCTypeWrite: self
    }.
}.

CVoid := CType scalarTag: 1 Size: 0 Align: 1.
CInt8 := CType scalarTag: 2 Size: 1 Align: 1.
CUInt8 := CType scalarTag: 3 Size: 1 Align: 1.
CInt16 := CType scalarTag: 4 Size: 2 Align: 2.
CUInt16 := CType scalarTag: 5 Size: 2 Align: 2.
CInt32 := CType scalarTag: 6 Size: 4 Align: 4.
CUInt32 := CType scalarTag: 7 Size: 4 Align: 4.
CInt64 := CType scalarTag: 8 Size: 8 Align: 8.
CUInt64 := CType scalarTag: 9 Size: 8 Align: 8.
CFloat32 := CType scalarTag: 10 Size: 4 Align: 4.
CFloat64 := CType scalarTag: 11 Size: 8 Align: 8.
CPointer := CType scalarTag: 12 Size: 8 Align: 8.
CSize := CType scalarTag: 13 Size: 8 Align: 8.

Object extend: CInt8 With: {
    proxyReadFrom: p At: o = { p i8At: o }.
    proxyWriteTo: p At: o Value: v = { p i8At: o Put: v }.
}.

Object extend: CUInt8 With: {
    proxyReadFrom: p At: o = { p u8At: o }.
    proxyWriteTo: p At: o Value: v = { p u8At: o Put: v }.
}.

Object extend: CInt16 With: {
    proxyReadFrom: p At: o = { p i16At: o }.
    proxyWriteTo: p At: o Value: v = { p i16At: o Put: v }.
}.

Object extend: CUInt16 With: {
    proxyReadFrom: p At: o = { p u16At: o }.
    proxyWriteTo: p At: o Value: v = { p u16At: o Put: v }.
}.

Object extend: CInt32 With: {
    proxyReadFrom: p At: o = { p i32At: o }.
    proxyWriteTo: p At: o Value: v = { p i32At: o Put: v }.
}.

Object extend: CUInt32 With: {
    proxyReadFrom: p At: o = { p u32At: o }.
    proxyWriteTo: p At: o Value: v = { p u32At: o Put: v }.
}.

Object extend: CInt64 With: {
    proxyReadFrom: p At: o = { p i64At: o }.
    proxyWriteTo: p At: o Value: v = { p i64At: o Put: v }.
}.

Object extend: CUInt64 With: {
    proxyReadFrom: p At: o = { p u64At: o }.
    proxyWriteTo: p At: o Value: v = { p u64At: o Put: v }.
}.

Object extend: CFloat32 With: {
    proxyReadFrom: p At: o = { p f32At: o }.
    proxyWriteTo: p At: o Value: v = { p f32At: o Put: v }.
}.

Object extend: CFloat64 With: {
    proxyReadFrom: p At: o = { p f64At: o }.
    proxyWriteTo: p At: o Value: v = { p f64At: o Put: v }.
}.

Object extend: CPointer With: {
    proxyReadFrom: p At: o = { p pointerAt: o }.
    proxyWriteTo: p At: o Value: v = { p pointerAt: o Put: v }.
}.

Object extend: CSize With: {
    proxyReadFrom: p At: o = { p u64At: o }.
    proxyWriteTo: p At: o Value: v = { p u64At: o Put: v }.
}.

// Example struct descriptor protocol (field order defines layout):
CStatPairExample := CType struct: {
    first = CInt32.
    second = CInt32.
}.

CDivT := CType struct: {
    quot = CInt32.
    rem = CInt32.
}.

// Linux x86_64 glibc struct stat layout.
CStatLinuxX64 := CType struct: {
    st_dev = CUInt64.
    st_ino = CUInt64.
    st_nlink = CUInt64.
    st_mode = CUInt32.
    st_uid = CUInt32.
    st_gid = CUInt32.
    st_pad0 = CUInt32.
    st_rdev = CUInt64.
    st_size = CInt64.
    st_blksize = CInt64.
    st_blocks = CInt64.
    st_atime = CInt64.
    st_atime_nsec = CInt64.
    st_mtime = CInt64.
    st_mtime_nsec = CInt64.
    st_ctime = CInt64.
    st_ctime_nsec = CInt64.
    st_reserved0 = CInt64.
    st_reserved1 = CInt64.
    st_reserved2 = CInt64.
}.

Posix := {
    parent* = Oddball.
    SEEK_SET = 0.
    SEEK_CUR = 1.
    SEEK_END = 2.
    O_RDONLY = 0.

    libc := Alien libraryOpen: "libc.so.6".
    initialized := False.
    functions := {
        open := None.
        lseek := None.
        close := None.
        fstat := None.
        read := None.
        div := None
    }.

    ensureFunctions = {
        fns := self functions.
        self initialized
            ifTrue: [ None ]
            IfFalse: [
                fns open: (self libc librarySym: "open").
                fns lseek: (self libc librarySym: "lseek").
                fns close: (self libc librarySym: "close").
                fns fstat: (self libc librarySym: "fstat").
                fns read: (self libc librarySym: "read").
                fns div: (self libc librarySym: "div").
                self initialized: True
            ].
        fns
    }.

    open: path Flags: flags Mode: mode = {
        self ensureFunctions open
            callWithTypes: CPointer & CInt32 & CInt32
            Args: path & flags & mode
            ReturnType: CInt32
    }.

    seekFd: fd Offset: offset Whence: whence = {
        self ensureFunctions lseek
            callWithTypes: CInt32 & CInt32 & CInt64
            Args: fd & offset & whence
            ReturnType: CInt64
    }.

    closeFd: fd = {
        self ensureFunctions close
            callWithTypes: CInt32
            Args: fd
            ReturnType: CInt32
    }.

    fstatFd: fd Into: buffer = {
        self ensureFunctions fstat
            callWithTypes: CInt32 & CPointer
            Args: fd & buffer
            ReturnType: CInt32
    }.

    readFd: fd Into: buffer Length: len = {
        self ensureFunctions read
            callWithTypes: CInt32 & CPointer & CSize
            Args: fd & buffer & len
            ReturnType: CInt64
    }.

    div: lhs By: rhs = {
        self ensureFunctions div
            callWithTypes: CInt32 & CInt32
            Args: lhs & rhs
            ReturnType: CDivT
    }.

    close = { self libc libraryClose }.
}.

(File open: "core/init.ktt" Flags: Posix O_RDONLY Mode: 0) using: [ | file |
    ("Reading: core/init.ktt (Size: " + file size toString + "):") println.
    file 
        eachLine: [ | line |
            line println
        ]
        First: 3
].

(VM _Eval: "NewGlobal = \"incredible\". 10 + 44") toString println.
NewGlobal println.
